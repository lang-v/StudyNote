# 计算机网网络

### 计算机基础（通信UDP\TCP\IP 三次握手、四次挥手）

#### OSI七层模型

1. 应用层
2. 表示层
3. 会话层
4. 传输层 ：TCP/IP TCP报文首部20字节、IP报文首部20字节、UDP首部8个字节
5. 网络层
6. 数据链路层
7. 物理层

#### UDP

User Datagarm Protocol  用户数据报协议，位于OSI模型中的运输层

特点：

- 无连接
- 不可靠
- 快速传输（首部开销小）

##### UDP报文段格式

![UDP首部字段](https://upload-images.jianshu.io/upload_images/2053709-4b2a2f4e00243758.png?imageMogr2/auto-orient/strip|imageView2/2/w/1180/format/webp)

其中分为两个部分：UDP伪首部、UDP首部

1. UDP伪首部：

共12字节：4字节源IP地址、4字节目的IP地址、填充0(占一个字节)、一个字节协议字段（UDP为17、TCP为16）、两个字节UDP长度（与下面的首部字段中的长度一致）

*注意* ：这些字段的不会向下传送也不会向上递交，是从IP分组的头部获取的。

2. UDP**首部字段**

（仅有8个字节即64个比特，首部开销较小也是它的优势之一）分为四个字段每个字段占2字节：

1. 前两个字段分别为**16位的源端口号和16位目的端口号**（计算机端口共65535个即2的16次方-1）

2. 后两个字段分别是长度、检验和，同样都是两个字节的长度

   - 长度：单位为**字节**，最大表示长度就为2^16 = 65535字节，那么数据报单次传输内容的长度限制是不是就是它呢？

   - 检验和：UDP通过检验和提供差错检测功能。将前面三个字段（源端口号、目的端接口号、长度）相加得到的值取反码即为检验和

##### UDP差错检测

已知检验和为源端口号、目的端接口号、长度三者相加得到的值取反码，那么三者相加的值再加上检验和 等于 一个所有位数都为1的二进制数。例如： 和为1001 0110，则检验和为：0110 1001

 1001 0110+0110 1001 = 1111 1111

则可以通过的最后结果中有没有0来判断数据是否出现差错

#### TCP

Tranform Controller Protocol 传输控制协议，同样位于OSI模型中的运输层。

##### 特点

- 面向字节流
- 提供全双工通信
- 可靠的通信方式（无差错、不丢失、不重复）
- 面向连接的单播协议
- 在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销
- 通信连接维护时面向通信的两个端口的，而不考虑中间网段和节点

##### TCP报文段格式

![TCP报文段格式](http://5b0988e595225.cdn.sohucs.com/images/20180910/fdb152e3d8f547b7bec66b537844dce2.jpeg)

ACK —— 确认，使得确认号有效。 RST —— 重置连接（经常看到的reset by peer）就是此字段搞的鬼。 SYN —— 用于初如化一个连接的序列号。 FIN —— 该报文段的发送方已经结束向对方发送数据。

![三次握手，四次挥手](https://pic3.zhimg.com/80/v2-e8aaab48ff996e5cd8a5b39dc450bd6a_720w.jpg)

##### 三次握手

最明显的作用就是使得双方都明确对方的收、发功能正常，同时相比直接连接无须三次握手相比，极大程度上减少了服务器被恶意攻击多次连接导致服务器大量资源处于等待阶段，从而导致资源浪费。

*注*：报文段中存在一个序号Seq number 和一个确认序号Ack number，此外还有一个ACK字段位长度为1。只有当ACK为1时Ack number才有效

1. 第一次握手 

   客户端向服务器发送SYN报文，即SYN字段值为1

2. 第二次握手

   服务器接收到SYN报文说明客户端的发功能正常，接着向客户端发送SYNACk报文，即SYN、ACK字段值为1，且Ack number = Seq number+1 表明收到了上一个报文

3. 第三次握手

   客户端接收到SYNACK报文说明服务器的收发能力都正常，向服务器发送ACK报文，Ack number = 上一个Seq number+1 表明收到了上一个报文，使得服务器知道客户端的收发能力正常，即连接成功。

##### 四次挥手

![四次挥手](https://pic3.zhimg.com/80/v2-629f51f6f535ebd7683f944707b21d1e_720w.jpg)

1. 第一次挥手

   客户端发送FIN报文，并附带当前Seq number、Ack number 和ACK用于确认收到了上一个包。

2. 第二次挥手

   服务器接收到FIN报文，会将还没发送的数据发送，然后发送ACK报文，此时客户端不会再发送消息了即发功能已关闭，只是再等待服务器发送的关闭报文。

3. 第三次挥手

   服务器发送FIN报文，Ack number  = 客户端FIN报文序号Seq number + 1,ACK = 1。

4. 第四次挥手

   客户端接收到FIN报文，向服务器发送ACK报文，Ack number = 服务器FIN报文序号Seq number + 1 ，ACK = 1。

##### 为什么建立连接是三次握手而断开连接是四次挥手？

建立连接时需要判断双方的收发能力是否正常，而要完成这个操作最少需要发送三次报文，即三次握手；分析建立连接时发送的报文可以看到，三次握手发送的报文分别为 SYN 、SYN+ACK、ACK三个报文，即第二次握手时同时发送了SYN建立连接ACK确认报文，而断开连接报文分别是：FIN、ACK、FIN、ACk，很明显是中间的ACK和FIN报文分开发送了，它们不能合并的原因是服务器接收到客户端的FIN报文，说明客户端想要关闭连接了，即客户端不会再发送消息，但是依然能接收消息，此时服务器可以选择立即关闭连接也可以选择把没发送的报文发送过去再关闭连接，所以会将FIN和ACK报文分开等到服务器将要发送的报文发送完毕，再发送FIN报文通知客户端现在关闭连接。

##### 滑动窗口机制

提高发送效率，TCP为了保证报文段的有序性使用了send-wait-send机制，需要在发送后收到确认才会继续发送下一个报文，效率较低。采用滑动窗口机制提高发送效率。

在同一时间发送多个报文段，不需要等待客户端确认。如果客户端接受时发现报文段未有序到达或者丢失，此时便返回确认报文段告知发送方自己期望收到的是哪一个序号的报文，发送方再重新发送此报文；最后接受方收到了期望的序号，会继续告知发送方下一个期望收到的报文序号，发送方通过此报文控制发送窗口的前移。

**注意**：TCP不建议控制发送窗口收缩，可能会导致错误

##### 流量控制

 通过可变窗口控制发送速率。

##### 拥塞控制 

TCP拥塞控制算法分四种

1. 慢开始&拥塞避免

   慢开始，通过控制发送窗口的大小，达到目的， RFC5681 规定初始拥塞窗口（等于发送窗口）的大小为2-4个最大报文段数量（SMSS）。拥塞窗口的大小是递增的（算法：**拥塞窗口cwnd每次的增加量 = min(N,SMSS)** ）。N为收到的确认报文段所确认收到的字节数。总结来看就是每次过一个轮次cwnd就翻一倍。

   拥塞避免，相比慢开始的翻倍增加，拥塞避免选择每经过一个往返时间RTT就让cwnd加1。线性增长使得网络不容易出现网络拥塞。

   **何时使用慢开始和拥塞避免**：ssthresh 慢开始门限，当发生超时时（即发生了网络拥塞），**ssthresh将被重置为当前cwnd/2 ,cwnd将被置为1**。

   - cwnd < ssthresh  慢开始
   - cwnd > ssthresh 停止慢开始使用拥塞避免
   - cwnd = ssthresh 两者皆可

2. 快重传&快恢复

   上述两种算法在报文丢失时会重置cwnd为1，对于网络拥塞时是非常有效的。如果报文在网络中丢失但是并没有发生网络拥塞，此时将会降低发送效率。

   使用场景：收到M1，M2 丢失M3，后续收到M4-M7的时候发送对M2的确认，共重复三次。

   ![](https://img-blog.csdn.net/20170415161738770?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

   收到三次对M2的重复，发送方就会对M3进行立即重传（所以整个过程对M2进行四次重传） ，因为三次重复确认所以不会启动慢开始，而是启动快恢复，调整 ssthresh = cwnd = cwnd/2 ,然后开始执行拥塞避免算法（ssthresh <= cwnd）

##### 安全

1. DDoS 拒绝服务攻击（SYN洪水攻击）

   攻击者发送大量的TCP SYN报文段，但是不完成第三次握手，导致服务器不断地为这些半开连接（但是未被使用）从而耗尽资源。应对方法Syn cookie

### http & https

#### 加密算法 

1. 对称式加密

   生成同一个密钥，可以对数据进行加密解密。

2. 非对称式加密

   典型代表有RSA ，生成两个密钥，一个公钥为公开的所有人都可以拿到用于加密，一个私钥不公开用于解密。

现在的Https请求一般通过两种方式混合使用。

[https加密原理解析](https://juejin.cn/post/6844903569343119367)

